"""
Vulnerability Scanner

Detects common web vulnerabilities including:
- Cross-Site Scripting (XSS)
- SQL Injection
- Open Redirects
- Insecure Forms
- Mixed Content
- Suspicious JavaScript
"""

import requests
import re
from typing import Dict, List, Any
from urllib.parse import urlparse, urljoin
from bs4 import BeautifulSoup


class VulnerabilityScanner:
    """Web vulnerability scanner for common security issues"""
    
    # XSS test payloads
    XSS_PAYLOADS = [
        '<script>alert(1)</script>',
        '"><script>alert(1)</script>',
        "javascript:alert(1)",
        '<img src=x onerror=alert(1)>',
    ]
    
    # SQL injection patterns
    SQLI_PATTERNS = [
        r"SQL syntax.*MySQL",
        r"Warning.*mysql_.*",
        r"valid MySQL result",
        r"MySqlClient\.",
        r"PostgreSQL.*ERROR",
        r"Warning.*\Wpg_.*",
        r"valid PostgreSQL result",
        r"Npgsql\.",
        r"Driver.* SQL[\-\_\ ]*Server",
        r"OLE DB.* SQL Server",
        r"SQLServer JDBC Driver",
        r"Microsoft SQL Native Client error",
    ]
    
    def __init__(self):
        self.results = {}
    
    def scan(self, url: str) -> Dict[str, Any]:
        """
        Scan for common web vulnerabilities
        
        Args:
            url: Target URL to scan
            
        Returns:
            Dictionary containing scan results
        """
        try:
            results = {
                'url': url,
                'issues': [],
                'vulnerabilities': {
                    'xss': [],
                    'sqli': [],
                    'open_redirect': [],
                    'mixed_content': [],
                    'insecure_forms': [],
                    'suspicious_js': []
                }
            }
            
            # Fetch the page
            response = requests.get(
                url,
                timeout=10,
                verify=True,
                headers={'User-Agent': 'DevSecScan/1.0 Security Scanner'}
            )
            
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Check for mixed content
            mixed_content = self._check_mixed_content(url, soup)
            if mixed_content:
                results['vulnerabilities']['mixed_content'] = mixed_content
                results['issues'].extend(mixed_content)
            
            # Check for insecure forms
            insecure_forms = self._check_insecure_forms(url, soup)
            if insecure_forms:
                results['vulnerabilities']['insecure_forms'] = insecure_forms
                results['issues'].extend(insecure_forms)
            
            # Check for potential XSS
            xss_vulns = self._check_xss_vulnerabilities(url, soup)
            if xss_vulns:
                results['vulnerabilities']['xss'] = xss_vulns
                results['issues'].extend(xss_vulns)
            
            # Check for suspicious JavaScript
            suspicious_js = self._check_suspicious_javascript(soup)
            if suspicious_js:
                results['vulnerabilities']['suspicious_js'] = suspicious_js
                results['issues'].extend(suspicious_js)
            
            # Check for open redirects
            open_redirects = self._check_open_redirects(url, soup)
            if open_redirects:
                results['vulnerabilities']['open_redirect'] = open_redirects
                results['issues'].extend(open_redirects)
            
            # Check for SQL injection indicators (passive)
            sqli_indicators = self._check_sqli_indicators(response.text)
            if sqli_indicators:
                results['vulnerabilities']['sqli'] = sqli_indicators
                results['issues'].extend(sqli_indicators)
            
            # Calculate score
            score, grade = self._calculate_score(results)
            results['score'] = score
            results['grade'] = grade
            
            return results
            
        except Exception as e:
            return {
                'error': str(e),
                'score': 0,
                'grade': 'F',
                'issues': [{
                    'severity': 'critical',
                    'message': f'Failed to scan for vulnerabilities: {str(e)}',
                    'recommendation': 'Ensure the website is accessible'
                }]
            }
    
    def _check_mixed_content(self, url: str, soup: BeautifulSoup) -> List[Dict[str, str]]:
        """Check for mixed content (HTTP resources on HTTPS page)"""
        issues = []
        
        if not url.startswith('https://'):
            return issues
        
        # Check images
        for img in soup.find_all('img'):
            src = img.get('src', '')
            if src.startswith('http://'):
                issues.append({
                    'severity': 'medium',
                    'type': 'mixed_content',
                    'message': f'Mixed content: HTTP image on HTTPS page: {src}',
                    'recommendation': 'Use HTTPS for all resources',
                    'fix': f'Change to: {src.replace("http://", "https://")}'
                })
        
        # Check scripts
        for script in soup.find_all('script'):
            src = script.get('src', '')
            if src.startswith('http://'):
                issues.append({
                    'severity': 'high',
                    'type': 'mixed_content',
                    'message': f'Mixed content: HTTP script on HTTPS page: {src}',
                    'recommendation': 'Use HTTPS for all scripts - this is a security risk',
                    'fix': f'Change to: {src.replace("http://", "https://")}'
                })
        
        # Check stylesheets
        for link in soup.find_all('link', rel='stylesheet'):
            href = link.get('href', '')
            if href.startswith('http://'):
                issues.append({
                    'severity': 'medium',
                    'type': 'mixed_content',
                    'message': f'Mixed content: HTTP stylesheet on HTTPS page: {href}',
                    'recommendation': 'Use HTTPS for all stylesheets',
                    'fix': f'Change to: {href.replace("http://", "https://")}'
                })
        
        return issues
    
    def _check_insecure_forms(self, url: str, soup: BeautifulSoup) -> List[Dict[str, str]]:
        """Check for forms submitting over HTTP"""
        issues = []
        
        for form in soup.find_all('form'):
            action = form.get('action', '')
            method = form.get('method', 'get').lower()
            
            # Check if form submits to HTTP
            if action.startswith('http://'):
                issues.append({
                    'severity': 'high',
                    'type': 'insecure_form',
                    'message': f'Form submits data over insecure HTTP: {action}',
                    'recommendation': 'Use HTTPS for form submissions',
                    'fix': f'Change form action to: {action.replace("http://", "https://")}'
                })
            
            # Check for password fields over HTTP
            if url.startswith('http://'):
                password_fields = form.find_all('input', type='password')
                if password_fields:
                    issues.append({
                        'severity': 'critical',
                        'type': 'insecure_form',
                        'message': 'Password field on non-HTTPS page',
                        'recommendation': 'Never transmit passwords over HTTP',
                        'fix': 'Enable HTTPS for the entire website'
                    })
        
        return issues
    
    def _check_xss_vulnerabilities(self, url: str, soup: BeautifulSoup) -> List[Dict[str, str]]:
        """Check for potential XSS vulnerabilities (passive detection)"""
        issues = []
        
        # Check for inline event handlers (potential XSS vectors)
        event_handlers = ['onclick', 'onerror', 'onload', 'onmouseover']
        
        for tag in soup.find_all():
            for handler in event_handlers:
                if tag.get(handler):
                    issues.append({
                        'severity': 'medium',
                        'type': 'xss',
                        'message': f'Inline event handler found: {tag.name} with {handler}',
                        'recommendation': 'Avoid inline event handlers, use CSP and external JavaScript',
                        'fix': 'Move JavaScript to external files and use Content-Security-Policy'
                    })
                    break  # Only report once per tag
        
        # Check for user input reflection (basic check)
        parsed_url = urlparse(url)
        if parsed_url.query:
            page_text = soup.get_text()
            for param in parsed_url.query.split('&'):
                if '=' in param:
                    key, value = param.split('=', 1)
                    if value and value in page_text:
                        issues.append({
                            'severity': 'high',
                            'type': 'xss',
                            'message': f'URL parameter "{key}" appears to be reflected in page content',
                            'recommendation': 'Ensure all user input is properly sanitized and encoded',
                            'fix': 'Use HTML encoding for output: htmlspecialchars() in PHP, escape() in JavaScript'
                        })
        
        return issues
    
    def _check_suspicious_javascript(self, soup: BeautifulSoup) -> List[Dict[str, str]]:
        """Check for suspicious JavaScript patterns"""
        issues = []
        
        suspicious_patterns = {
            r'eval\s*\(': 'Use of eval() detected - potential code injection risk',
            r'document\.write\s*\(': 'Use of document.write() - can be exploited for XSS',
            r'innerHTML\s*=': 'Direct innerHTML assignment - potential XSS risk',
            r'\.fromCharCode\s*\(': 'Character code obfuscation detected',
        }
        
        for script in soup.find_all('script'):
            script_content = script.string or ''
            
            for pattern, message in suspicious_patterns.items():
                if re.search(pattern, script_content, re.IGNORECASE):
                    issues.append({
                        'severity': 'medium',
                        'type': 'suspicious_js',
                        'message': message,
                        'recommendation': 'Review JavaScript code for security issues',
                        'fix': 'Use safer alternatives and implement Content-Security-Policy'
                    })
        
        return issues
    
    def _check_open_redirects(self, url: str, soup: BeautifulSoup) -> List[Dict[str, str]]:
        """Check for potential open redirect vulnerabilities"""
        issues = []
        
        # Check for redirect parameters in links
        redirect_params = ['redirect', 'url', 'next', 'return', 'goto', 'target']
        
        for link in soup.find_all('a', href=True):
            href = link['href']
            parsed = urlparse(href)
            
            if parsed.query:
                for param in redirect_params:
                    if param in parsed.query.lower():
                        issues.append({
                            'severity': 'medium',
                            'type': 'open_redirect',
                            'message': f'Potential open redirect parameter found: {param} in {href}',
                            'recommendation': 'Validate and whitelist redirect URLs',
                            'fix': 'Implement URL validation: only allow redirects to trusted domains'
                        })
                        break
        
        return issues
    
    def _check_sqli_indicators(self, response_text: str) -> List[Dict[str, str]]:
        """Check for SQL injection error messages (passive)"""
        issues = []
        
        for pattern in self.SQLI_PATTERNS:
            if re.search(pattern, response_text, re.IGNORECASE):
                issues.append({
                    'severity': 'critical',
                    'type': 'sqli',
                    'message': 'SQL error message detected in response - potential SQL injection vulnerability',
                    'recommendation': 'Use parameterized queries and never display SQL errors to users',
                    'fix': 'Use prepared statements: $stmt = $pdo->prepare("SELECT * FROM users WHERE id = ?");'
                })
                break  # Only report once
        
        return issues
    
    def _calculate_score(self, results: Dict[str, Any]) -> tuple:
        """Calculate vulnerability score (0-100)"""
        score = 100
        
        # Deduct points for issues
        for issue in results.get('issues', []):
            severity = issue.get('severity', 'low')
            if severity == 'critical':
                score -= 25
            elif severity == 'high':
                score -= 15
            elif severity == 'medium':
                score -= 10
            elif severity == 'low':
                score -= 5
        
        score = max(0, min(100, score))
        
        # Determine grade
        if score >= 95:
            grade = 'A+'
        elif score >= 85:
            grade = 'A'
        elif score >= 75:
            grade = 'B'
        elif score >= 65:
            grade = 'C'
        elif score >= 50:
            grade = 'D'
        else:
            grade = 'F'
        
        return score, grade

